


# 依赖

dependencies {
  compile 'io.vertx:vertx-web:3.4.2'
}



# 工作原理

Vert.x Web 维护了零或多个 Route 的对象。

Router 接收 HTTP 请求，并查找首个匹配该请求的 Route，然后将请求传递给这个 Route。

Route 可以持有一个与之关联的处理器用于接收请求。
您可以通过这个处理器对请求做一些事情，然后结束响应或者把请求传递给下一个匹配的处理器。



# 一般步骤


HttpServer server = vertx.createHttpServer();

Router router = Router.router(vertx);

router.route().handler(routingContext -> {

  // 所有的请求都会调用这个处理器处理
  HttpServerResponse response = routingContext.response();
  response.putHeader("content-type", "text/plain");

  // 写入响应并结束处理
  response.end("Hello World from Vert.x-Web!");
});

server.requestHandler(router::accept).listen(8080);\




# Route路径匹配


##  路径匹配 

精确匹配

可以将 Route 设置为只匹配指定的 URI。在这种情况下它只会匹配路径和该路径一致的请求。

在下面这个例子中会被路径为 /some/path/ 的请求调用。我们会忽略结尾的 /，所以路径 /some/path 或者 /some/path// 的请求也是匹配的：

## 方法匹配




# 多个路由 next 

默认的路由的匹配顺序与添加到 Router 的顺序一致。

当一个请求到达时，Router 会一步一步检查每一个 Route 是否匹配，如果匹配则对应的处理器会被调用。

如果处理器随后调用了 next，则下一个匹配的 Route 对应的处理器（如果有）会被调用，以此类推。

# 阻塞式处理


# 上下文数据

  在请求的生命周期中，
  您可以通过路由上下文 RoutingContext 来维护任何您希望在处理器之间共享的数据。
  
# 处理请求

处理请求消息体
您可以使用消息体处理器 BodyHandler 来获取请求的消息体，限制消息体大小，或者处理文件上传。

您需要保证消息体处理器能够匹配到所有您需要这个功能的请求。

由于它需要在所有异步执行之前处理请求的消息体，因此这个处理器要尽可能早地设置到 router 上。

router.route().handler(BodyHandler.create());
获取请求的消息体
如果您知道消息体的类型是 JSON，您可以使用 getBodyAsJson；如果您知道它的类型是字符串，您可以使用 getBodyAsString；否则可以通过 getBody 作为 Buffer 来处理。


  
  